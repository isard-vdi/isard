#!/bin/bash

#===============================================================================
# QCOW2 Guest Filesystem Repair Script
#===============================================================================
# Description: Detects and repairs corrupted guest filesystems inside qcow2
#              disk images using guestfish and filesystem-specific tools.
#              Can be called standalone or from the sparsify script.
#
# Usage: repair-qcow2 [OPTIONS] <file.qcow2>
#
# Options:
#   --dry-run    List filesystems and what would be done without touching anything
#   --verbose    Show full repair output
#   --help       Display this help message
#
# Exit codes:
#   0 - Repairs applied successfully or nothing to repair
#   1 - Repair failed
#   2 - File not accessible or in use
#
# Example:
#   repair-qcow2 --dry-run --verbose /isard/groups/disk.qcow2
#   repair-qcow2 /isard/groups/disk.qcow2
#===============================================================================

set -o pipefail

#-------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------
DRY_RUN=false
VERBOSE=false

#-------------------------------------------------------------------------------
# Color Codes
#-------------------------------------------------------------------------------
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

#-------------------------------------------------------------------------------
# Function: log
#-------------------------------------------------------------------------------
log() {
    local level="$1"
    shift
    case "$level" in
        INFO)    echo -e "${BLUE}[repair-qcow2 INFO]${NC} $*" >&2 ;;
        WARN)    echo -e "${YELLOW}[repair-qcow2 WARN]${NC} $*" >&2 ;;
        ERROR)   echo -e "${RED}[repair-qcow2 ERROR]${NC} $*" >&2 ;;
        SUCCESS) echo -e "${GREEN}[repair-qcow2 OK]${NC} $*" >&2 ;;
    esac
}

#-------------------------------------------------------------------------------
# Function: show_help
#-------------------------------------------------------------------------------
show_help() {
    sed -n '3,24p' "$0" | sed 's/^# \?//'
    exit 0
}

#-------------------------------------------------------------------------------
# Function: parse_arguments
#-------------------------------------------------------------------------------
parse_arguments() {
    while [ $# -gt 0 ]; do
        case "$1" in
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --help)
                show_help
                ;;
            -*)
                log ERROR "Unknown option: $1"
                echo "Use --help for usage information" >&2
                exit 1
                ;;
            *)
                if [ -z "$QCOW2_FILE" ]; then
                    QCOW2_FILE="$1"
                else
                    log ERROR "Unexpected argument: $1"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [ -z "$QCOW2_FILE" ]; then
        log ERROR "No qcow2 file specified"
        echo "Usage: repair-qcow2 [--dry-run] [--verbose] <file.qcow2>" >&2
        exit 1
    fi
}

#-------------------------------------------------------------------------------
# Function: validate_file
# Description: Check file exists, is qcow2, and is not in use
# Returns: 0 if valid, exits with 2 otherwise
#-------------------------------------------------------------------------------
validate_file() {
    local file="$1"

    # Check file exists
    if [ ! -f "$file" ]; then
        log ERROR "File not found: $file"
        exit 2
    fi

    # Check it's a qcow2 file
    local img_info
    img_info=$(qemu-img info "$file" 2>&1)
    local rc=$?

    if [ $rc -ne 0 ]; then
        # Check if it's a lock/in-use error
        if echo "$img_info" | grep -q "Failed to get.*lock\|Is another process using"; then
            log ERROR "File is in use by another process: $file"
            exit 2
        fi
        log ERROR "Cannot read file (qemu-img info failed): $file"
        [ "$VERBOSE" = true ] && echo "$img_info" >&2
        exit 2
    fi

    if ! echo "$img_info" | grep -q "file format: qcow2"; then
        log ERROR "Not a qcow2 file: $file"
        exit 2
    fi

    log INFO "Validated qcow2 file: $file"
}

#-------------------------------------------------------------------------------
# Function: discover_filesystems
# Description: Use guestfish to list partitions and their filesystem types
# Sets global FS_LIST as newline-separated "device:fstype" entries
#-------------------------------------------------------------------------------
discover_filesystems() {
    local file="$1"

    log INFO "Discovering filesystems in: $file"

    local gf_output
    gf_output=$(guestfish --ro -a "$file" run : list-filesystems 2>&1)
    local rc=$?

    if [ $rc -ne 0 ]; then
        log ERROR "Failed to list filesystems (guestfish error)"
        [ "$VERBOSE" = true ] && echo "$gf_output" >&2
        return 1
    fi

    # guestfish list-filesystems outputs lines like:
    #   /dev/sda1: ext4
    #   /dev/sda2: swap
    FS_LIST=""
    while IFS= read -r line; do
        # Skip empty lines
        [ -z "$line" ] && continue
        # Parse "device: fstype"
        local dev fstype
        dev=$(echo "$line" | cut -d: -f1 | tr -d ' ')
        fstype=$(echo "$line" | cut -d: -f2 | tr -d ' ')
        [ -z "$dev" ] || [ -z "$fstype" ] && continue
        if [ -z "$FS_LIST" ]; then
            FS_LIST="${dev}:${fstype}"
        else
            FS_LIST="${FS_LIST}"$'\n'"${dev}:${fstype}"
        fi
    done <<< "$gf_output"

    if [ -z "$FS_LIST" ]; then
        log WARN "No filesystems found in image"
        return 0
    fi

    local fs_count
    fs_count=$(echo "$FS_LIST" | wc -l)
    log INFO "Found $fs_count filesystem(s)"

    if [ "$VERBOSE" = true ]; then
        echo "$FS_LIST" | while IFS=: read -r dev fstype; do
            log INFO "  $dev -> $fstype"
        done
    fi
}

#-------------------------------------------------------------------------------
# Function: repair_filesystem
# Description: Repair a single filesystem using the appropriate tool
# Arguments: $1 - qcow2 file, $2 - device (e.g. /dev/sda1), $3 - fstype
# Returns: 0 if repaired/skipped, 1 if repair failed
#-------------------------------------------------------------------------------
repair_filesystem() {
    local file="$1"
    local dev="$2"
    local fstype="$3"

    case "$fstype" in
        ext2|ext3|ext4)
            log INFO "Repairing $dev ($fstype) with e2fsck..."
            if [ "$DRY_RUN" = true ]; then
                log INFO "  DRY RUN: would run guestfish e2fsck-f $dev"
                return 0
            fi
            local output
            output=$(guestfish --rw -a "$file" run : e2fsck-f "$dev" 2>&1)
            local rc=$?
            if [ "$VERBOSE" = true ]; then
                echo "$output" >&2
            fi
            if [ $rc -ne 0 ]; then
                log ERROR "e2fsck failed on $dev (exit $rc)"
                return 1
            fi
            log SUCCESS "Repaired $dev ($fstype)"
            ;;
        xfs)
            log INFO "Repairing $dev ($fstype) with xfs_repair..."
            if [ "$DRY_RUN" = true ]; then
                log INFO "  DRY RUN: would run xfs_repair on $dev"
                return 0
            fi
            # xfs_repair must run on unmounted filesystem; use guestfish sh command
            local output
            output=$(guestfish --rw -a "$file" run : sh "xfs_repair $dev" 2>&1)
            local rc=$?
            if [ "$VERBOSE" = true ]; then
                echo "$output" >&2
            fi
            if [ $rc -ne 0 ]; then
                log ERROR "xfs_repair failed on $dev (exit $rc)"
                return 1
            fi
            log SUCCESS "Repaired $dev ($fstype)"
            ;;
        ntfs)
            log INFO "Repairing $dev ($fstype) with ntfsfix..."
            if [ "$DRY_RUN" = true ]; then
                log INFO "  DRY RUN: would run ntfsfix -d on $dev"
                return 0
            fi
            local output
            output=$(guestfish --rw -a "$file" run : sh "ntfsfix -d $dev" 2>&1)
            local rc=$?
            if [ "$VERBOSE" = true ]; then
                echo "$output" >&2
            fi
            if [ $rc -ne 0 ]; then
                log ERROR "ntfsfix failed on $dev (exit $rc)"
                return 1
            fi
            log SUCCESS "Repaired $dev ($fstype)"
            ;;
        btrfs)
            log WARN "Skipping $dev ($fstype) - btrfsck --repair is too risky for auto-repair"
            ;;
        swap|unknown|"")
            log INFO "Skipping $dev ($fstype) - no repair needed"
            ;;
        *)
            log WARN "Skipping $dev ($fstype) - unsupported filesystem type"
            ;;
    esac

    return 0
}

#-------------------------------------------------------------------------------
# Function: verify_image
# Description: Run qemu-img check after repairs
# Returns: 0 if image is OK, 1 if check fails
#-------------------------------------------------------------------------------
verify_image() {
    local file="$1"

    if [ "$DRY_RUN" = true ]; then
        log INFO "DRY RUN: would run qemu-img check"
        return 0
    fi

    log INFO "Verifying image integrity with qemu-img check..."
    local output
    output=$(qemu-img check "$file" 2>&1)
    local rc=$?

    if [ "$VERBOSE" = true ]; then
        echo "$output" >&2
    fi

    if [ $rc -ne 0 ] && [ $rc -ne 3 ]; then
        # rc=3 means leaks were found (non-fatal), anything else is a real error
        log ERROR "Image integrity check failed (exit $rc)"
        return 1
    fi

    log SUCCESS "Image integrity verified: $file"
    return 0
}

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------
main() {
    parse_arguments "$@"

    validate_file "$QCOW2_FILE"

    # Discover filesystems
    if ! discover_filesystems "$QCOW2_FILE"; then
        exit 1
    fi

    if [ -z "$FS_LIST" ]; then
        log INFO "No filesystems to repair"
        exit 0
    fi

    # Repair each filesystem
    local had_failure=false
    local had_repair=false

    while IFS=: read -r dev fstype; do
        if ! repair_filesystem "$QCOW2_FILE" "$dev" "$fstype"; then
            had_failure=true
        else
            # Track if we actually did something (not just skipped)
            case "$fstype" in
                ext2|ext3|ext4|xfs|ntfs)
                    had_repair=true
                    ;;
            esac
        fi
    done <<< "$FS_LIST"

    if [ "$had_failure" = true ]; then
        log ERROR "One or more repairs failed"
        exit 1
    fi

    # Verify image integrity after repairs
    if [ "$had_repair" = true ]; then
        if ! verify_image "$QCOW2_FILE"; then
            exit 1
        fi
    fi

    if [ "$DRY_RUN" = true ]; then
        log INFO "Dry run complete - no changes made"
    else
        log SUCCESS "All repairs completed successfully"
    fi

    exit 0
}

main "$@"
